${complexType.name}.hpp
/* Autogenerated with Kurento Idl */

#ifndef __${camelToUnderscore(complexType.name)}_HPP__
#define __${camelToUnderscore(complexType.name)}_HPP__

#include <jsoncpp/json/json.h>
#include <jsonrpc/JsonRpcException.hpp>
#include <memory>

namespace kurento {
class JsonSerializer;
class ${complexType.name};

void Serialize(std::shared_ptr<kurento::${complexType.name}>& object, JsonSerializer& s);

<#list complexType.getChildren() as dependency>
<#if childs??>

</#if>
<#if model.remoteClasses?seq_contains(dependency.type.type) ||
  model.complexTypes?seq_contains(dependency.type.type) ||
  model.events?seq_contains(dependency.type.type)><#assign childs=true>
class ${dependency.type.name};
</#if>
</#list>

class ${complexType.name}
{

public:

<#assign createEmptyConstructor = true>
<#if complexType.typeFormat == "REGISTER">
  ${complexType.name} (<#rt>
    <#assign createEmptyConstructor = false>
    <#lt><#list complexType.properties as property><#rt>
      <#lt><#if !property.optional><#rt>
        <#lt><#if (first) ??>, </#if><#rt>
        <#lt><#assign first = true><#rt>
        <#lt>${getCppObjectType(property.type)} ${property.name}<#rt>
      <#lt></#if><#rt>
    <#lt></#list>){
    <#list complexType.properties as property><#rt>
      <#lt><#if !property.optional><#rt>
      <#assign createEmptyConstructor = true>
    this->${property.name} = ${property.name};
      </#if><#rt>
    <#lt></#list>
  };

  ${complexType.name} (const Json::Value &value);

  <#list complexType.properties as property>
  void set${property.name?cap_first} (${getCppObjectType(property.type)} ${property.name}) {
    this->${property.name} = ${property.name};
    <#if property.optional>
    _isSet${property.name?cap_first} = true;
    </#if>
  };

  ${getCppObjectType(property.type, false)} get${property.name?cap_first} () {
    return ${property.name};
  };

  <#if property.optional>
  bool isSet${property.name?cap_first} () {
    return _isSet${property.name?cap_first};
  };

  </#if>
  </#list>
private:
  <#list complexType.properties as property>
  ${getCppObjectType(property.type, false)} ${property.name};
  <#if property.optional>
  bool _isSet${property.name?cap_first} = false;
  </#if>
  </#list>
<#elseif complexType.typeFormat == "ENUM">
  typedef enum {
  <#list complexType.values as value>
    ${value}<#if value_has_next>,</#if>
  </#list>
  } type;

  ${complexType.name} (const std::string &type) {

    <#list complexType.values as value>
    if (type ==  "${value}") {
      enumValue = ${value};
    }

    </#list>
  };

  ${complexType.name} (type value) {
    this->enumValue = value;
  }

  type getValue () {
    return enumValue;
  };

  std::string getString () {

    <#list complexType.values as value>
    if (enumValue ==  ${value}) {
      return "${value}";
    }

    </#list>
    return "";
  }

private:

  type enumValue;

<#else>
// TODO: Type format ${complexType.typeFormat} not supported
</#if>

  <#if createEmptyConstructor >
  ${complexType.name}() {};
  </#if>

  friend void Serialize(std::shared_ptr<${complexType.name}>& object, JsonSerializer& s);
};

} /* kurento */

#endif /*  __${camelToUnderscore(complexType.name)}_HPP__ */
